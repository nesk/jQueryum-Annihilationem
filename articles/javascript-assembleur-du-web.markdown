Title: JavaScript, l’Assembleur du web
Author: Johann Pardanaud
Date: Fri Oct 12 2012 14:09:30 GMT+0200 (CEST)

Voici un petit article quelque peu particulier que j’ai rédigé suite à la proposition de Timothée “Mitknil” Bernard. Son projet était d’écrire une introduction à la création d’un petit langage qui se compile en JavaScript, mais pour cela il avait besoin d’une introduction à ce dernier et sur les raisons qui pouvait pousser certaines personnes à lui ajouter une ou plusieurs couches d’abstraction.

Après rédaction, Timothée a ajouté ma partie à son article, [que vous pouvez (et devez !) consulter sur son blog](http://timothee-bernard.fr/creons-notre-propre-langage-et-son-compilateur-javascript.html). Je vous conseille d’ajouter son blog à votre lecteur RSS ou à vos favoris, il vous enseignera de nombreuses choses dans des domaines trop peu abordés !

Vous trouverez donc ci-dessous la partie de l’article que j’ai rédigée pour le blog de Timothée mais je vous conseille plutôt de vous orienter vers l’article complet lié ci-dessus.

## JavaScript, triste langage que tu es...

Voilà plus de 15 ans que le JavaScript a fait son apparition au sein des navigateurs web. Prévu au départ pour être un simple langage de script capable de fournir un minimum d’interaction à l’utilisateur au sein d’une page web, il a su évoluer pour devenir, finalement, ce qu’il est aujourd’hui : une nécessité pour nos sites web.

En soit, le JavaScript est un langage très pauvre. Sa richesse est, au final, composée de tout ce qui peut lui être greffé par les navigateurs (ou les plateformes telles que [Node.js](http://nodejs.org/)) : la manipulation du [DOM](http://fr.wikipedia.org/wiki/Document_Object_Model), les requêtes [AJAX](http://fr.wikipedia.org/wiki/Ajax_(informatique)), la lecture/écriture de fichiers, etc…

Sans ces greffons, le JavaScript n’est pas un langage que l’on peut considérer comme pratique ou évolué : inexistence des classes, attributs des objets constamment publics, aucune notion native d’héritage ou de namespace, _variable scoping_ bancal et c’est loin d’être fini, la liste est longue ! Mais alors pourquoi ce langage est-il si utilisé ? Tout simplement parce qu’il est le seul langage de script disponible au sein des navigateurs. Dit comme ça, c’est un peu honteux, mais cela est malheureusement la vérité. Cependant, il possède tout de même quelques atouts qui font qu’il commence à émerger dans d’autres domaines que les navigateurs web (Node.js est un très bon exemple).

## L’apport des librairies : essentiel mais limité

Afin de pallier les défauts du langage, la communauté de développeurs JavaScript a fait émerger diverses solutions au travers de nombreuses librairies dont les plus connues sont [jQuery](http://jquery.com/) et [Mootools](http://mootools.net/). Bien que ces librairies permettent une utilisation plus aisée du JavaScript, elles ne changent pas le fonctionnement interne du langage et vous vous rendez alors bien vite compte que vous y gagnez seulement en productivité et que vous êtes toujours tributaire des limitations de ce langage. Dans bien des cas cela suffit, mais si vous cherchez à développer de manière structurée sur une plateforme qui n’accepte que le JavaScript (tels que les navigateurs web) alors ce n’est pas une librairie qui pourra vous permettre de donner le meilleur de vous-même (bien que les librairies telles que [Backbone.js](http://backbonejs.org/) soient d’une aide déjà considérable).

## « Les librairies c’est so 2011 »

Bien après l’émergence des librairies JavaScript, une nouvelle manière de penser est arrivée : plutôt que de chercher à faire évoluer ce langage, pourquoi ne pas plutôt le subtiliser à un autre ? L’idée paraît simple, voir même évidente, mais malheureusement cela n’est pas possible au sein d’une plateforme qui ne supporte que le JavaScript, c’est pourquoi ces dernières années une autre solution s’est mise à fleurir au beau milieu de cet océan qu’est le web : créer un langage de toutes pièces et le compiler en JavaScript !

Vous demanderez probablement au premier abord quel est l’intérêt : comment un langage plus « haut niveau »  (que nous nommerons temporairement « A »)  pourrait-il avoir un quelconque intérêt de plus ? Après tout, les notions intégrées au langage « A » seront forcément faussées une fois la compilation en JavaScript effectuée. Effectivement, imaginons que notre langage « A » introduise le concept des attributs privés, seront-ils toujours privés au sein du code Javascript obtenu après compilation ? Non, et ceci n’est en réalité pas un problème car pensez-vous réellement que, lorsqu’un langage tel que le C++ est compilé en Assembleur, le concept de POO est conservé après compilation ? Non, et cela est normal : le langage que vous utilisez vous fourni des notions disponibles uniquement avant compilation, car vous n’êtes normalement pas censés toucher au résultat compilé.

Si nous reprenons ce qui a été dit au précédent paragraphe, vous pouvez constater que nous avons comparé la compilation en JavaScript à celle en Assembleur, cela n’est pas anodin et nous amène à une réflexion relativement profonde sur l’état actuel du JavaScript et son avenir : ce langage est-il « l’Assembleur du web » ? En effet, bien que les deux langages soient radicalement différents, ils se ressemblent dans leur manière de fonctionner car ils sont tous deux relativement peu agréables à utiliser mais sont essentiels à leur propre domaine. Ils possèdent donc tous deux diverses couches d’abstraction sous formes de langages à compiler.

Qu’est-ce qui peut nous faire croire que le JavaScript s’oriente de plus en plus vers ce système de couches ? Et bien il suffit de regarder les choses en face : le nombre de langages qui se compilent en JavaScript ne fait qu’augmenter et [ils sont déjà bien nombreux](https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS) ! De grandes entreprises y ont même participé : Google avec [Dart](http://www.dartlang.org/) et, plus récemment, Microsoft avec [TypeScript](http://www.typescriptlang.org/). Bien que tous ces langages ne soient pas un succès, nous assistons tout de même à une démocratisation et une amélioration du principe.

Et si le JavaScript venait à évoluer au point de ne plus nécessiter de couches d’abstraction ? Pour cela, il est fort probable que cela n’arrive pas avant un bon nombre d’années car, rien qu’à regarder [les spécifications temporaires de l’ECMAScript 6](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts), on peut constater que des nouveautés ont été ajoutées afin d’augmenter les caractéristiques du langage (les mot-clés `let` et `const`, les générateurs, les itérateurs, etc…) mais rien n’est présent pour améliorer drastiquement l’usage du langage. Il semblerait que le comité qui conçoit les spécifications de l’ECMAScript veuille avancer prudemment afin d’éviter le fiasco vécu lors de la conception de l’ECMAScript 4, ce qui veut dire que le langage va en changeant, oui, mais lentement, beaucoup plus lentement que les couches d’abstraction qui existent pour le JavaScript.

## Alors, JavaScript ou simili-JavaScript ?

Pour terminer sur cette partie, ne croyez pas que le JavaScript sans librairies ou couches d’abstraction est bon à jeter à la poubelle, loin de là ! Ce langage a encore énormément d’avenir devant lui et aucun autre ne semble encore prêt à prendre la relève pour la tâche qui lui incombe. Si vous souhaitez vous mettre au JavaScript, prenez le temps de vous en servir tel quel avant de vous jeter sur les librairies et les couches disponibles, familiarisez-vous avec et le jour où vous finirez par en ressentir le réel besoin, passez sur des outils plus avancés.